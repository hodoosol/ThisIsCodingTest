"""
이것이 코딩 테스트다 2021 강의 몰아보기
2021.04.20

Chapter 4. 정렬

"""


"""
1. 정렬 알고리즘이란 ?
 - 정렬(Sorting)이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.
 - 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용된다.





2. 선택 정렬
 - 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다.
 
 7  5  9  0  3  1  6  2  4  8 를 선택 정렬로 정렬해보자.
  1) 처리되지 않은 데이터 중 가장 작은 0을 선택해 가장 앞의 7과 바꾼다.
       0  5  9  7  3  1  6  2  4  8
  2) 처리되지 않은 데이터 중 가장 작은 1을 선택해 가장 앞의 5와 바꾼다.
       0  1  9  7  3  5  6  2  4  8
  3) 처리되지 않은 데이터 중 가장 작은 2를 선택해 가장 앞의 9와 바꾼다.
       0  1  2  7  3  5  6  9  4  8
  4) 처리되지 않은 데이터 중 가장 작은 3을 선택해 가장 앞의 7과 바꾼다.
       0  1  2  3  7  5  6  9  4  8
  5) 처리되지 않은 데이터 중 가장 작은 4를 선택해 가장 앞의 7과 바꾼다.
       0  1  2  3  4  5  6  9  7  8
  6) 처리되지 않은 데이터 중 가장 작은 5를 선택해 그대로 둔다.
  7) 처리되지 않은 데이터 중 가장 작은 6을 선택해 그대로 둔다.
  8) 처리되지 않은 데이터 중 가장 작은 7을 선택해 가장 앞의 9와 바꾼다.
       0  1  2  3  4  5  6  7  9  8
  9) 처리되지 않은 데이터 중 가장 작은 8을 선택해 가장 앞의 9와 바꾼다.
       0  1  2  3  4  5  6  7  8  9
  10) 마지막 9는 처리하지 않아도 된다.

 
 
"""


# 파이썬으로 선택정렬 코드를 작성해보자.

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)) :
    # 가장 작은 원소의 인덱스
    min_index = i
    for j in range(i + 1, len(array)) :
        if array[min_index] > array[j] :
            min_index= j
    # Swap
    array[i], array[min_index] = array[min_index], array[i]

print(array)





"""
3. 삽입 정렬
 - 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
 - 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.
 

 7  5  9  0  3  1  6  2  4  8 를 삽입 정렬로 정렬해보자.
  1) 첫 번째 데이터 7은 그 자체로 정렬이 되어있다고 판단하고,
     두 번째 데이터인 5가 어떤 위치로 들어갈지 판단한다.
     7의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재한다.
        5  7  9  0  3  1  6  2  4  8
  2) 이어서 9가 어떤 위치로 들어갈지 판단한다. 7보다 크기 때문에 바꾸지 않는다.
        5  7  9  0  3  1  6  2  4  8
  3) 이어서 0이 어떤 위치로 들어갈지 판단한다.
     0은 9보다 작으므로 9의 왼쪽으로, 그 다음인 7보다 작으므로 7의 왼쪽으로
     그 다음인 5보다 작으므로 5의 왼쪽으로 들어가게 된다.
        0  5  7  9  3  1  6  2  4  8
  4) 이어서 3이 어떤 위치로 들어갈지 판단한다.
     3은 9보다 작으므로 9의 왼쪽으로, 7보다 작으므로 7의 왼쪽,
     5보다 작으므로 5의 왼쪽, 0보단 크므로 0의 오른쪽으로 이동한다. 
        0  3  5  7  9  1  6  2  4  8
  5) 1이 어떤 위치로 들어갈지 판단한다.
        0  1  3  5  7  9  6  2  4  8
  6) 6이 어떤 위치로 들어갈지 판단한다.
        0  1  3  5  6  7  9  2  4  8
  7) 2가 어떤 위치로 들어갈지 판단한다.
        0  1  2  3  5  6  7  9  4  8
  8) 4가 어떤 위치로 들어갈지 판단한다.
        0  1  2  3  4  5  6  7  9  8
  9) 8이 어떤 위치로 들어갈지 판단한다. 완료 !
        0  1  2  3  4  5  6  7  8  9
     
     
     
"""


# 파이썬으로 삽입정렬 코드를 작성해보자.

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)) :
    # 인덱스 i부터 1까지 1씩 감소하며 반복
    for j in range(i, 0, -1) :
        # 한 칸씩 왼쪽으로 이동
        if array[j] < array[j - 1] :
            # Swap
            array[j], array[j - 1] = array[j - 1], array[j]
        # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
        else :
            break
print(array)





"""
4. 퀵 정렬
 - 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.
 - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나이다.
 - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 된다.
 - 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)으로 설정한다.
 
 
 
 5  7  9  0  3  1  6  2  4  8 를 퀵 정렬로 정렬해보자.
  1) 현재 피벗의 값은 5이다. 
     왼쪽에서부터 5보다 큰 데이터를 선택하므로 7이 선택되고,
     오른쪽에서부터 5보다 작은 데이터를 선택하므로 4가 선택된다. 이 두 데이터의 위치를 스왑한다.
        5  4  9  0  3  1  6  2  7  8
  2) 그 다음 왼쪽에서부터 피벗보다 큰 데이터인 9를 선택하고
     오른쪽에서부터 피벗보다 작은 데이터인 2를 선택하여 바꾼다.
        5  4  2  0  3  1  6  9  7  8
  3) 그 다음 왼쪽에서부터 피벗보다 큰 데이터는 6이 선택되고
     오른쪽에서부터 피벗보다 작은 데이터는 1이 선택되는데, 위치가 엇갈리게된 것을 알 수 있다.
     이 경우, 피벗과 작은 데이터의 위치를 서로 변경한다. 즉 5와 1을 변경한다.
        1  4  2  0  3  5  6  9  7  8
         [분할 완료] 이제 5의 왼쪽에 있는 데이터는 모두 5보다 작고
          오른쪽에 있는 데이터는 모두 5보다 커지게 된다.
          이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 분할 이라고 한다.
          ** 이렇게 나눈 묶음을 다시 정렬할 때는 재귀적으로 수행된다.
             즉, 점점 데이터의 묶음이 작아지는 것이다.
  4) 이제 피벗 5를 기준으로 왼쪽에 있는 데이터를 정렬한다. (묶음 정렬)
        1  4  2  0  3    피벗 : 1
        4와 0을 택해서 바꿔준다.
        1  0  2  4  3
        위치가 엇갈리게 되었으므로 1과 0을 바꾼다.
        0  1  2  4  3    
        피벗을 기준으로 왼쪽 묶음은 정렬이 완료되었으니 오른쪽 묶음을 정렬한다.
        2  4  3          피벗 : 2
        피벗보다 작은 데이터가 없으므로 피벗을 기준으로 오른쪽 묶음을 정렬한다.
        4  3             피벗 : 4
        위치가 엇갈리게 되었으므로 피벗과 작은 데이터를 스왑한다.
        3  4
        이제 왼쪽 묶음은 정렬이 완료되었다. 0  1  2  3  4
  5) 피벗 5를 기준으로 오른쪽에 있는 데이터를 정렬한다.
        6  9  7  8       피벗 : 6
        피벗보다 작은 데이터가 없으므로 피벗을 기준으로 오른쪽 묶음을 정렬한다.      
        9  7  8          피벗 : 9
        피벗보다 작은 데이터 8과 피벗을 스왑하고, 피벗을 기준으로 왼쪽 묶음을 정렬한다.
        8  7             피벗 : 8
        위치가 엇갈리게 되었으므로 피벗과 작은 데이터를 스왑한다.
        7  8
        이제 오른쪽 묶음의 정렬도 완료되었다. 6  7  8  9
  6) 모든 데이터의 정렬이 완료되었다.
     점점 작은 묶음으로 쪼개져갈 때, 퀵 정렬이 멈추는 조건은
     리스트의 원소가 1개인 경우이다. 이미 정렬되어 있다고 판단하는 것이다.
     
     
 ** 퀵 정렬이 빠른 이유 ?
  - 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)을 기대할 수 있다.
      너비 * 높이 = N * logN = NlogN                      
        
퀵 정렬의 시간 복잡도
 - 퀵 정렬은 평균적으로 O(NlogN)의 시간 복잡도를 가진다.
 - 하지만 최악의 경우 O(N^2)가 된다.
   첫 번째 원소를 피벗을 삼을 때, 이미 정렬된 배열에서 퀵 정렬을 수행하면 어떻게 될까 ?
       0  1  2  3  4  5  6  7  8  9    피벗 : 0
       왼쪽에서부터 큰 데이터 : 1 오른쪽에서부터 작은 데이터 : 0 가 되므로
       피벗을 기준으로 오른쪽 묶음을 정렬한다. 
       왼쪽 묶음은 [0] 이므로 리스트의 길이가 1이라 정렬이 완료되어있다.
       1  2  3  4  5  6  7  8  9       피벗 : 1
       왼쪽에서부터 큰 데이터 : 2 오른쪽에서부터 작은 데이터 : 1 이 되므로
       피벗을 기준으로 오른쪽 묶음을 정렬한다.
       왼쪽 묶음은 [1] 이므로 리스트의 길이가 1이라 정렬이 완료되어있다.
       2  3  4  5  6  7  8  9
       ...
       ...
   이런식으로 매번 분할이 이루어질 때 마다 모든 데이터를 다 거쳐야하므로 O(N^2)가 될 수도 있다.
   
     
"""



# 파이썬으로 퀵정렬 코드를 작성해보자.

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end) :
    # 원소가 1개인 경우 종료한다.
    if start >= end :
        return
    # 피벗은 첫 번째 원소
    pivot = start
    left = start + 1
    right = end
    while (left <= right) :
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while (left <= end and array[left] <= array[pivot]) :
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while (right > start and array[right] >= array[pivot]) :
            right -= 1
        # 엇갈렸다면 작은 데이터와 피벗을 교체
        if (left > right) :
            array[right], array[pivot] = array[pivot], array[right]
        # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
        else :
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)





"""
5. 계수 정렬
 - 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작한다.
    특정한 조건 ? 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때
 - 데이터의 개수가 n, 데이터(양수) 중 최댓값이 k일 때 최악의 경우에도
   수행 시간 O(N + K)를 보장한다.
   

 7  5  9  0  3  1  6  2  9  1  4  8  0  5  2 를 계수 정렬로 정렬해보자.
  1) 가장 작은 데이터 0부터 가장 큰 데이터 9까지의 범위가 모두 담길 수 있도록 리스트를 생성한다.
      list = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  2) 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.
     맨 처음 데이터는 7 이므로
      list = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0] 가 된다.
  3) 다음은 데이터는 5 이므로
      list = [0, 0, 0, 0, 0, 4, 0, 1, 0, 0] 가 된다.
  4) 이런 식으로 모든 데이터를 다 세어주면
      list = [2, 2, 2, 1, 1, 2, 1, 1, 1, 2] 가 된다. 
  5) 이제 리스트의 첫 번째 데이터부터 하나씩 해당하는 값만큼 반복하여 인덱스를 출력한다.
      0 0 1 1 2 2 3 4 5 5 6 7 8 9 9 (0은 2개, 1은 2개, 2는 2개, 3은 1개 ...)
       -> 정렬 완료 !

** 계수 정렬의 복잡도 분석
 - 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N + K) 이다.
 - 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.
   데이터가 0과 999,999로 단 2개만 존재하는 경우, 아주 긴 빈 리스트를 만들게 된다.
 - 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있다.
   성적의 경우 100점을 맞는 학생이 여러명일 수 있기 때문에 효과적이다.


"""



# 파이썬으로 계수정렬 코드를 작성해보자.

# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언 (값은 0으로 초기화)
count = [0] * (max(array) + 1)

# 각 데이터에 해당하는 인덱스의 값 증가
for i in range(len(array)) :
    count[array[i]] += 1

for i in range(len(count)) :
    for j in range(count[i]) :
        print(i, end=' ')





"""
5. 정렬 알고리즘 비교하기
 - 앞서 다룬 네 가지 정렬 알고리즘을 비교해보자.
 - 추가적으로 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는
   최악의 경우에도 O(NlogN)을 보장하도록 설계되어 있다.
   
               평균 시간복잡도      공간 복잡도                    특징
               
 선택정렬         O(N^2)             O(N)             아이디어가 매우 간단하다.
 
 삽입정렬         O(N^2)             O(N)        데이터가 거의 정렬되어 있을 때 가장 빠르다.
 
 퀵정렬          O(NlogN)            O(N)        대부분의 경우에 가장 적합하고 빠른 편이다.
 
 계수정렬        O(N + K)          O(N + K)   데이터의 크기가 한정되어 있는 경우에만 사용이 가능.
                                                     BUT, 매우 빠르게 동작한다.
                                                                
                                                     
"""



# 선택 정렬과 기본 정렬 라이브러리의 수행 시간을 비교해보자.
from random import randint
import time

# 배열에 1만개의 정수를 삽입
array = []
for _ in range(10000) :
    # 1 부터 100 사이의 랜덤한 정수
    array.append(randint(1, 100))

# 선택 정렬 프로그램 성능 측정 시작
start_time = time.time()

# 선택 정렬 프로그램 소스코드
for i in range(len(array)) :
    # 가장 작은 원소의 인덱스
    min_index = i
    for j in range(i + 1, len(array)) :
        if array[min_index] > array[j] :
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]

# 성능 측정 종료
end_time = time.time()
# 수행 시간 출력
print('선택 정렬 성능 측정 : ', end_time - start_time)


# 배열을 다시 무작위 데이터로 초기화
array = []
for _ in range(10000) :
    # 1 부터 100 사이의 랜덤한 정수
    array.append(randint(1, 100))

# 기본 정렬 라이브러리 성능 측정 시장
start_time = time.time()

# 기본 정렬 라이브러리 사용
array.sort()

# 측정 종료
end_time = time.time()
# 수행 시간 출력
print('기본 정렬 라이브러리 성능 측정 : ', end_time - start_time)





"""
# 두 배열의 원소 교체 : 문제 설명

다솔이는 두 개의 배열 A와 B를 가지고 있다.
두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다.
다솔이는 최대 K 번의 바꿔치기 연산을 수행할 수 있는데,
바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라
두 원소를 서로 바꾸는 것을 말한다.
다솔이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며,
우리는 다솔이를 도와야 한다.
N, K 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K 번의 바꿔치기 연산을 수행하여
만들 수 있는 배열 A의 모든 원소의 합과 최댓값을 출력하는 프로그램을 작성하시오.

ex) n = 5, k = 3, A = [1, 2, 5, 4, 3], B = [5, 5, 6, 6, 5]
이 경우, 세 번의 연산을 수행할 수 있다.
   1. 배열 A의 원소 1과 배열 B의 원소 6을 바꾸기
   2. 배열 A의 원소 2와 배열 B의 원소 6을 바꾸기
   3. 배열 A의 원소 3과 배열 B의 원소 5를 바꾸기
연산의 결과는 이렇게 된다.
A = [6, 6, 5, 4, 5]
B = [3, 5, 1, 2, 5]
이 때 A의 모든 원소의 합은 6 + 6 + 5 + 4 + 5 = 26이 되고, 이것이 최대값이다.

** 문제 해결 아이디어
핵심 아이디어 : 매번 A에서 가장 작은 원소를 골라 B의 가장 큰 원소와 교체한다.
가장 먼저 A, B가 주어지면 A에 대하여 오름차순 정렬하고 B에 대해 내림차순 정렬한다.
이후 두 배열의 원소를 첫 번째 인덱스로부터 차례로 확인하면서
A의 원소가 B의 원소보다 작을 때에만 교체를 수행한다.
이 문제에서는 두 배열의 원소가 최대 100,000개까지 입력될 수 있으므로
최악의 경우 O(NlogN)을 보장하는 정렬 알고리즘을 이용해야 한다.


"""


# 두 배열의 원소 교체 : 내 답
n, k = map(int, input().split())
a = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))

for i in range(k) :
    if b[len(b) - 1 - i] > a[i] :
        a[i], b[len(b) - 1 - i]  = b[len(b) - 1 - i], a[i]
    else :
        break

print(sum(a))



# 두 배열의 원소 교체 : 답안 예시
n, k = map(int, input().split())
a = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))

a.sort()
b.sort(reverse=True)

for i in range(k) :
    if a[i] < b[i] :
        a[i], b[i] = b[i], a[i]
    else :
        break

print(sum(a))




