"""
이것이 코딩 테스트다 2021 강의 몰아보기
2021.04.07

Chapter 2. 그리디 & 구현

"""


"""
1. 그리디 알고리즘(탐욕법) 개요

그리디 알고리즘이란 ?
 - 현재 상황에서 지금 당장 좋은 것만을 고르는 방법.
   가장 좋아보이는 것을 반복적으로 선택하는 것이 최적의 답일까 ? 생각해야 함.
   
동전의 개수를 최소로 하여 거스름 돈을 만드는 문제를 풀어보자.
점원이 가지고 있는 동전이 500, 100, 50, 10원 일 때는
큰 동전이 항상 작은 동전의 배수가 된다.
때문에 탐욕법을 사용하여 가장 큰 동전인 500원부터 거슬러주면 최적의 해가 나온다.
ex) 1260원 = 500, 500, 100, 100, 50, 10 원, 6개의 동전

그러나 점원이 가지고 있는 동전이 500, 400, 100인 경우
800원을 거슬러주어야 한다면 가장 큰 동전부터 거슬러주어서
800 = 500, 100, 100, 100원, 4개의 동전을 얻는 것 보다
800 = 400, 400원으로 2개의 동전을 얻는 것이 최적이다.

따라서 탐욕법을 사용할 때는
알고리즘이 항상 최적의 해를 보장할 수 있는지 검토해야 한다.

"""



# 거스름 돈 답안 예시
n = 1260
cnt = 0

coins = [500, 100, 50, 10]

for i in coins :
    cnt += n // i
    n %= i

print(cnt)

# 시간 복잡도 분석
# coins의 종류가 k라고 할 때, 위 알고리즘의 시간 복잡도는 O(k)이다.








"""
2. 그리디 유형 문제 풀이

1) 1이 될 때까지
어떠한 수 n이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.
단, 두 번째 연산은 n이 k로 나누어 떨어질 때만 선택할 수 있다.

1. n에서 1을 뺀다.
2. n을 k로 나눈다.

예를 들어 n이 17, k가 4라고 가정해보자.
1번의 과정을 한 번 수행하면 n은 16이 되고 이후 2번 과정을 두 번 수행하면 1이 된다.
결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다.
이는 n을 1로 만드는 최소 횟수이다.

n과 k가 주어질 때, n이 1이 될 때까지 
1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하라.


** 문제 해결 아이디어
주어진 n에 대하여 최대한 많이 나누기를 수행하면 된다.
why ? n에서 1을 빼는 것보다 2 이상의 수로 나누는 것이 훨씬 답을 줄일 수 있기 때문.

ex) n = 25, k = 3

n - 1         n = 24
n / k         n = 8
n - 1         n = 7
n - 1         n = 6
n / k         n = 2
n - 1         n = 1       완성 ! 답 : 6


"""


# 1이 될 때까지 _ 내 답
n, k = map(int, input().split())
cnt = 0

while n != 1 :
    if n % k == 0 :
        n //= k
        cnt += 1
    else :
        n -= 1
        cnt += 1

print(cnt)



# 1이 될 때까지 _ 답안 예시
n, k = map(int, input().split())
result = 0

while True :
    # n이 k로 나누어 떨어지지 않을 때, 가장 가까운 k로 나누어지는 n 찾기
    target = (n // k) * k
    result += (n - target)
    n = target
    # n이 k보다 작을 때(더이상 나눌 수 없을 때) 반복문 탈출
    if n < k :
        break
    # k로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)





"""
2) 곱하기 혹은 더하기

각 자리가 숫자(0부터 9)로만 이루어진 문자열 s가 주어졌을 때,
왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며
숫자 사이에 'x' 혹은 '+' 연산자를 넣어
만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.

단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리
모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정한다.

ex) 02984라는 문자열로 만들 수 있는 가장 큰 수는
((((0 + 2) x 9) x 8) x 4) = 576이다.

** 문제 해결 아이디어
대부분의 경우 + 보다는 x 가 값을 더 크게 만든다.
다만 두 수 중에 하나라도 0 혹은 1인 경우
곱하기보다는 더할 때 더 큰 결과값이 나온다.
따라서 두 수가 모두 2 이상인 경우 곱하는 것이 포인트.


"""



# 곱하기 혹은 더하기 _ 내 답
s = list(input())
res = int(s[0])

for i in range(1, len(s)) :
    if int(s[i]) <= 1 or res <= 1 :
        res += int(s[i])
    else :
        res *= int(s[i])

print(res)



# 곱하기 혹은 더하기 _ 답안 예시(내 답이랑 거의 비슷)
data = input()
# 첫 번째 문자를 숫자로 변경하여 대입
result = int(data[0])

for i in range(1, len(data)) :
    # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 더하기 수행
    num = int(data[i])
    if num <= 1 or result <= 1 :
        result += num
    else :
        result *= num

print(result)





"""
3) 모험가 길드
한 마을에 모험가가 n명 있다. 
모험가 길드에서는 n명의 모험가를 대상으로 '공포도'를 측정했는데
공포도가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다.

모험가 길드장인 다솔이는 모험가 그룹을 안전하게 구성하고자
공포도가 x인 모험가는 반드시 x명 이상으로 구성한 모험가 그룹에 참가해야
여행을 떠날 수 있도록 규정했다.

다솔이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금하다.
n명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최대 값을 구하시오.

ex) n = 5
각 모험가의 공포도는 2 3 1 2 2 이다.
1 2 3 / 2 2 로 총 2개의 그룹을 만들 수 있다.

"""


# 모험가 길드 _ 내 답
n = int(input())
# 입력받은 뒤 내림차순 정렬
fear = sorted(list(map(int, input().split())), reverse=True)
# 공포도의 길이, 결과 값, 순서 세는 도움 변수
cnt = len(fear)
res = 0
i = 0
# 공포도의 길이가 0이 되면 break
while cnt != 0 :
    # 그룹 하나 생성
    res += 1
    # 공포도의 길이에서 지금 공포도의 수만큼 인원을 빼서 그룹 결성
    cnt -= fear[i]
    # fear[i]을 i에 더해줘서
    # 아직 그룹을 결성하지 않은 모험가의 차례로 점프
    i += fear[i]
# 출력
print(res)



# 모험가 길드 _ 답안 예시
n = int(input())
data = list(map(int, input().split()))
data.sort()

# 총 그룹수, 현재 그룹에 포함된 모험가의 수
result = 0
count = 0

# 곧포도를 낮은것 부터 하나씩 확인하며
for i in data :
    # 현재 그룹에 해당 모험가를 포함시키기
    count += 1
    # 현재 그룹에 포함된 모험가의 수가 현재 공포도 이상이라면, 그룹 결성
    if count >= i :
        # 총 그룹의 수 증가시키기
        result += 1
        # 현재 그룹에 포함된 모험가의 수 초기화
        count = 0
# 출력
print(result)





